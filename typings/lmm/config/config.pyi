"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from typing import Literal, Self
from lmm.markdown.parse_yaml import MetadataPrimitive
from pydantic import BaseModel, field_validator, model_validator
from pydantic_settings import BaseSettings, PydanticBaseSettingsSource

"""
Read and write configuration file.

This file also contains the definitions of the models supported in the
package.
"""
ModelSource = Literal['OpenAI', 'Anthropic', 'Mistral', 'Gemini']
EmbeddingSource = Literal['OpenAI', 'Mistral', 'Gemini', 'SentenceTransformers']
SparseModel = Literal['prithivida/Splade_PP_en_v1', 'Qdrant/bm25']
DEFAULT_CONFIG_FILE = ...
DEFAULT_PORT_RANGE = ...
class LanguageModelSettings(BaseModel):
    """Specification of language sources and models."""
    model: str = ...
    temperature: float = ...
    max_tokens: int | None = ...
    max_retries: int = ...
    timeout: float | None = ...
    provider_params: dict[str, MetadataPrimitive] = ...
    model_config = ...
    def __hash__(self) -> int:
        """Make the object hashable by converting provider_params to a sorted tuple."""
        ...
    
    def get_model_source(self) -> ModelSource:
        ...
    
    def get_model_name(self) -> str:
        ...
    
    @field_validator('model', mode='after')
    @classmethod
    def validate_model_spec(cls, spec: str) -> str:
        ...
    
    @model_validator(mode='after')
    def validate_provider_params(self) -> Self:
        """Validate provider-specific parameters based on the source."""
        ...
    


class EmbeddingSettings(BaseSettings):
    """Specification of embeddings object."""
    dense_model: str = ...
    sparse_model: SparseModel = ...
    model_config = ...
    def get_model_source(self) -> EmbeddingSource:
        ...
    
    def get_model_name(self) -> str:
        ...
    
    @field_validator('dense_model', mode='after')
    @classmethod
    def validate_model_spec(cls, spec: str) -> str:
        ...
    


class ServerSettings(BaseSettings):
    """Server configuration settings."""
    mode: Literal["local", "remote"] = ...
    port: int = ...
    host: str = ...
    model_config = ...
    @field_validator('port')
    @classmethod
    def validate_port(cls, v: int) -> int:
        """Validate port number is in acceptable range."""
        ...
    


class Settings(BaseSettings):
    """
    A pydantic settings object containing the fields with the
    configuration information.

    Settings are saved and read from the configuration file in TOML
    format.

    Attributes:
        server: Server configuration settings
        embeddings: Embedding model configuration
        major: Primary language model for complex tasks
        minor: Secondary language model for simple tasks
        aux: Auxiliary language model for specialized tasks

    Note:
        At present, the Settings object only reads from config.toml in
        the project folder. This path and name can be customized via
        the model_config.
    """
    server: ServerSettings = ...
    embeddings: EmbeddingSettings = ...
    major: LanguageModelSettings = ...
    minor: LanguageModelSettings = ...
    aux: LanguageModelSettings = ...
    model_config = ...
    @classmethod
    def settings_customise_sources(cls, settings_cls: type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -> tuple[PydanticBaseSettingsSource, ...]:
        """Customize the order of settings sources."""
        ...
    


def serialize_settings(sets: Settings) -> str:
    """Transform the settings into a string in TOML format.

    Args:
        settings: The settings object to serialize

    Returns:
        TOML formatted string representation of settings

    Raises:
        ImportError: If tomlkit is not available
        ValueError: If settings cannot be serialized
    """
    ...

def export_settings(settings: Settings, file_path: str | Path | None = ...) -> None:
    """Save settings to file in TOML format.

    Args:
        settings: A settings object to save
        file_path: The settings file path (defaults to config.toml)

    Raises:
        ImportError: If tomlkit is not available
        OSError: If file cannot be written
        ValueError: If settings cannot be serialized
    """
    ...

def create_default_config_file(file_path: str | Path | None = ...) -> None:
    """Create a default settings file.

    Args:
        settings: Custom settings object (defaults to Settings())
        file_path: Target file path (defaults to config.toml)

    Raises:
        ImportError: If tomlkit is not available
        OSError: If file cannot be written
        ValueError: If settings cannot be serialized

    Example:
        ```python
        # Creates config.toml in base folder with default values
        create_default_settings_file()

        # Creates custom config file
        create_default_settings_file(file_path="custom_config.toml")
        ```
    """
    ...

def print_settings(settings: Settings) -> None:
    """Print settings in TOML format to stdout.

    Args:
        settings: The settings object to print

    Raises:
        ImportError: If tomlkit is not available
        ValueError: If settings cannot be serialized
    """
    ...

def load_settings(file_path: str | Path | None = ...) -> Settings:
    """Load settings from TOML file.

    Args:
        file_path: Path to settings file (defaults to config.toml)

    Returns:
        Loaded settings object

    Raises:
        FileNotFoundError: If settings file doesn't exist
        ValueError: If settings file is invalid
    """
    class TempSettings(Settings):
        ...
    
    

def format_pydantic_error_message(error_message: str) -> str:
    """Filter out verbose lines from pydantic error messages.

    Args:
        error_message: Raw pydantic error message

    Returns:
        Cleaned error message without verbose help text
    """
    ...

if not Path(DEFAULT_CONFIG_FILE).exists():
    ...
